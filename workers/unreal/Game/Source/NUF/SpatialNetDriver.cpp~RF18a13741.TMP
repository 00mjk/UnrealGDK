// Copyright (c) Improbable Worlds Ltd, All Rights Reserved

#include "SpatialNetDriver.h"
#include "SpatialNetConnection.h"
#include "EntityRegistry.h"
#include "EntityPipeline.h"
#include "SpatialConstants.h"
#include "SpatialInteropBlock.h"
#include "SpatialOS.h"
#include "SpatialOSComponentUpdater.h"
#include "Engine/ActorChannel.h"
#include "Net/RepLayout.h"
#include "Net/DataReplication.h"
#include "SpatialPackageMapClient.h"
#include "SpatialActorChannel.h"
#include "improbable/spawner/spawner.h"

//#include "Generated/SpatialInteropCharacter.h"

#define ENTITY_BLUEPRINTS_FOLDER "/Game/EntityBlueprints"



bool USpatialNetDriver::InitBase(bool bInitAsClient, FNetworkNotify* InNotify, const FURL& URL, bool bReuseAddressAndPort, FString& Error)
{
	if (!Super::InitBase(bInitAsClient, InNotify, URL, bReuseAddressAndPort, Error))
	{
		return false;
	}

	// make absolutely sure that the actor channel that we are using is our Spatial actor channel
	UChannel::ChannelClasses[CHTYPE_Actor] = USpatialActorChannel::StaticClass();

	SpatialOSInstance = NewObject<USpatialOS>(this);

	SpatialOSInstance->OnConnectedDelegate.AddDynamic(this,
		&USpatialNetDriver::OnSpatialOSConnected);
	SpatialOSInstance->OnConnectionFailedDelegate.AddDynamic(
		this, &USpatialNetDriver::OnSpatialOSConnectFailed);
	SpatialOSInstance->OnDisconnectedDelegate.AddDynamic(
		this, &USpatialNetDriver::OnSpatialOSDisconnected);

	auto workerConfig = FSOSWorkerConfigurationData();

	workerConfig.Networking.UseExternalIp = false;
	workerConfig.SpatialOSApplication.WorkerPlatform =
		bInitAsClient ? TEXT("UnrealClient") : TEXT("UnrealWorker");

	SpatialOSInstance->ApplyConfiguration(workerConfig);
	SpatialOSInstance->Connect();

	SpatialOSComponentUpdater = NewObject<USpatialOSComponentUpdater>(this);

	EntityRegistry = NewObject<UEntityRegistry>(this);

	return true;
}

bool USpatialNetDriver::InitConnect(FNetworkNotify* InNotify, const FURL& ConnectURL, FString& Error)
{
	if (!Super::InitConnect(InNotify, ConnectURL, Error))
	{
		return false;
	}
		
	// Create an unreal connection to the server
	UOculusNetConnection* Connection = NewObject<UOculusNetConnection>(NetConnectionClass);
	check(Connection);
	TSharedRef<FInternetAddr> InternetAddr = MakeShareable(OculusAddr);
	Connection->InitRemoteConnection(this, nullptr, ConnectURL, *InternetAddr, ovr_Net_IsConnected(OculusAddr->GetID()) ? USOCK_Open : USOCK_Pending);

	ServerConnection = Connection;
	Connections.Add(OculusAddr->GetID(), Connection);

	// Connect via OVR_Networking
	ovr_Net_Connect(OculusAddr->GetID());

	// Create the control channel so we can send the Hello message
	ServerConnection->CreateChannel(CHTYPE_Control, true, INDEX_NONE);

	return true;
}

bool USpatialNetDriver::InitListen(FNetworkNotify* InNotify, FURL& LocalURL, bool bReuseAddressAndPort, FString& Error)
{
	if (!InitBase(false, InNotify, LocalURL, bReuseAddressAndPort, Error))
	{
		return false;
	}

	// Listen for incoming peers
	if (!PeerConnectRequestDelegateHandle.IsValid())
	{
		auto OnlineSubsystem = static_cast<FOnlineSubsystemOculus*>(IOnlineSubsystem::Get(OCULUS_SUBSYSTEM));
		PeerConnectRequestDelegateHandle =
			OnlineSubsystem->GetNotifDelegate(ovrMessage_Notification_Networking_PeerConnectRequest)
			.AddUObject(this, &UOculusNetDriver::OnNewNetworkingPeerRequest);
	}

	UE_LOG(LogNet, Verbose, TEXT("Init as a listen server"));

	return true;
}

void USpatialNetDriver::OnSpatialOSConnected()
{
	UE_LOG(LogTemp, Warning, TEXT("Connected to SpatialOS."));

	SpatialInteropBlock = NewObject<USpatialInteropBlock>();
	SpatialInteropBlock->Init(EntityRegistry);
	SpatialOSInstance->GetEntityPipeline()->AddBlock(SpatialInteropBlock);

	ShadowActorPipelineBlock = NewObject<USpatialShadowActorPipelineBlock>();
	ShadowActorPipelineBlock->Init(EntityRegistry);
	SpatialOSInstance->GetEntityPipeline()->AddBlock(ShadowActorPipelineBlock);

	TArray<FString> BlueprintPaths;
	BlueprintPaths.Add(TEXT(ENTITY_BLUEPRINTS_FOLDER));

	EntityRegistry->RegisterEntityBlueprints(BlueprintPaths);

	// If we're the client, we can now ask the server to spawn our controller.
	if (ServerConnection)
	{
		auto LockedConnection = SpatialOSInstance->GetConnection().Pin();

		if (LockedConnection.IsValid())
		{
			LockedConnection->SendCommandRequest<improbable::spawner::Spawner::Commands::SpawnPlayer>(SpatialConstants::SPAWNER_ENTITY_ID,
				improbable::spawner::SpawnPlayerRequest(),
				worker::Option<std::uint32_t>(0),
				worker::CommandParameters());
		}
	}
}

void USpatialNetDriver::OnSpatialOSDisconnected()
{
	UE_LOG(LogTemp, Warning, TEXT("Disconnected from SpatialOS."));
}

void USpatialNetDriver::OnSpatialOSConnectFailed()
{
	UE_LOG(LogTemp, Warning, TEXT("Could not connect to SpatialOS."));
}

int32 USpatialNetDriver::ServerReplicateActors(float DeltaSeconds)
{
	int32 RetVal = Super::ServerReplicateActors(DeltaSeconds);

	if (!ShadowActorPipelineBlock)
	{
		return RetVal;
	}

#if WITH_SERVER_CODE
	/*
	for (int32 ClientId = 0; ClientId < ClientConnections.Num(); ClientId++)
	{
		UNetConnection* NetConnection = ClientConnections[ClientId];
		for (int32 ChannelId = 0; ChannelId < NetConnection->OpenChannels.Num(); ChannelId++)
		{
			UActorChannel* ActorChannel = Cast<UActorChannel>(NetConnection->OpenChannels[ChannelId]);
			if (!ActorChannel)
			{
				continue;
			}

			// TODO: Remove this once we are using our entity pipeline.
			if (!ActorChannel->Actor->IsA<ACharacter>())
			{
				continue;
			}

			// Get FRepState.
			auto RepData = ActorChannel->ActorReplicator;
			FRepState* RepState = RepData->RepState;
			if (!RepState)
			{
				continue;
			}

			// Get entity ID.
			// TODO: Replace with EntityId from registry corresponding to this replicated actor.
			FEntityId EntityId = 2;//EntityRegistry->GetEntityIdFromActor(ActorChannel->Actor);
			if (EntityId == FEntityId())
			{
				continue;
			}

			// Get shadow actor.
			ASpatialShadowActor* ShadowActor = ShadowActorPipelineBlock->GetShadowActor(EntityId);
			if (!ShadowActor)
			{
				UE_LOG(LogTemp, Warning, TEXT("Actor channel has no corresponding shadow actor. That means the entity hasn't been checked out yet."));
				continue;
			}

			// Write changed properties to SpatialOS.
			auto RepLayout = RepState->RepLayout;
			for (int k = RepState->HistoryStart; k <= RepState->HistoryEnd; k++)
			{
				auto Changed = RepState->ChangeHistory[k].Changed;
				if (Changed.Num() > 0)
				{
					for (int idx = 0; idx < Changed.Num(); idx++)
					{
						if (Changed[idx] == 0)
						{
							continue;
						}
						int CmdIndex = Changed[idx] - 1;

						// Ignore dynamic arrays.
						auto Type = RepLayout->Cmds[CmdIndex].Type;
						if (Type == REPCMD_Return || Type == REPCMD_DynamicArray)
						{
							continue;
						}

						UProperty* Property = RepLayout->Cmds[CmdIndex].Property;
						UProperty* ParentProperty = RepLayout->Parents[RepLayout->Cmds[CmdIndex].ParentIndex].Property;
						//ApplyUpdateToSpatial_Character(ActorChannel->Actor, CmdIndex, ParentProperty, Property, ShadowActor->ReplicatedData);

						FString ChangedProp = Property->GetNameCPP();
						UE_LOG(LogTemp, Warning, TEXT("Actor: %s, cmd %s"), *GetNameSafe(ActorChannel->Actor), *ChangedProp);
					}
				}
			}
		}
	}
	*/
#endif
	return RetVal;
}

void USpatialNetDriver::TickDispatch(float DeltaTime)
{
	Super::TickDispatch(DeltaTime);

	if (SpatialOSInstance != nullptr && SpatialOSInstance->GetEntityPipeline() != nullptr)
	{
		SpatialOSInstance->ProcessOps();
		SpatialOSInstance->GetEntityPipeline()->ProcessOps(SpatialOSInstance->GetView(), SpatialOSInstance->GetConnection(), GetWorld());
		SpatialOSComponentUpdater->UpdateComponents(EntityRegistry, DeltaTime);
		if (ShadowActorPipelineBlock)
		{
			ShadowActorPipelineBlock->ReplicateShadowActorChanges(DeltaTime);
		}
	}
}

bool USpatialNetDriver::AcceptNewPlayer()
{
	USpatialNetConnection* Connection = NewObject<USpatialNetConnection>(GetTransientPackage(), NetConnectionClass);
	check(Connection);
	
	// We create a "dummy" connection that corresponds to this player. This connection won't transmit any data.
	// We may not need to keep it in the future, but for now it looks like path of least resistance is to have one UPlayer (UConnection) per player.

	//Connection->InitRemoteConnection(this, nullptr, FURL(), FInternetAddr(), USOCK_Open);
	Notify->NotifyAcceptedConnection(Connection);
	AddClientConnection(Connection);

	// We will now ask GameMode/GameSession if it's ok for this user to join.
	// Note that in the initial implementation, we carry over no data about the user here (such as a unique player id, or the real IP)
	// In the future it would make sense to add metadata to the Spawn request and pass it here.
	// For example we can check whether a user is banned by checking against an OnlineSubsystem.
	FString ErrorMsg;
	AGameModeBase* GameMode = GetWorld()->GetAuthGameMode();
	if (GameMode)
	{
		//GameMode->PreLogin(Tmp, Connection->LowLevelGetRemoteAddress(), Connection->PlayerId, ErrorMsg);
	}
	/*
	if (!ErrorMsg.IsEmpty())
	{
		UE_LOG(LogNet, Log, TEXT("PreLogin failure: %s"), *ErrorMsg);
		NETWORK_PROFILER(GNetworkProfiler.TrackEvent(TEXT("PRELOGIN FAILURE"), *ErrorMsg, Connection));
		FNetControlMessage<NMT_Failure>::Send(Connection, ErrorMsg);
		Connection->FlushNet(true);
		//@todo sz - can't close the connection here since it will leave the failure message 
		// in the send buffer and just close the socket. 
		//Connection->Close();
	}
	else
	{
		WelcomePlayer(Connection);
	}*/

	// Go all the way to creating the player controller here.

	return true;
}


